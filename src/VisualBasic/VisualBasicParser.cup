package VisualBasic;

import java_cup.runtime.*;
import java.io.File;
import java.util.List;

parser code {:
	@Override
	public void report_error(String message, Object info) {
		// if (!((Symbol)info).value.toString().equals("null")){
			if (info instanceof String)
				System.err.println(" " + info + " " + message + "\n");
			else {
				StringBuffer m = new StringBuffer("Error ");
				if (info instanceof java_cup.runtime.Symbol) {
					m.append(("(Se ha encontrado el token \"" + ((Symbol)info).value + "\" en la linea "
						+ ((Symbol)info).left + 1 + ", columna " + ((Symbol)info).right + 1) + ")");
				}
				if (message.equals("Couldn't repair and continue parse"))
					m.append(" : No existe una regla por los momentos para este token.");
				else
					m.append(" : " + message);
				System.err.println(m);
			}
		// }
	}
	@Override
	public void syntax_error(Symbol s){
		System.err.println( "(Se ha encontrado el token \"" + sym.terminalNames[s.sym] + "\" en la linea " + (s.left+1) + ", columna" + (s.right+1) + ")" ); 
        expected();
	}

	public void expected(){
		List<Integer> token_list = this.expected_token_ids();
		if (token_list.size() <= 0){
			token_list = this.expected_token_ids();
		}
		String expected_tokens = "";
		for (int i = 0 ; i < token_list.size(); i++){
			int id = token_list.get(i);
			if (id == 1){
				continue;
			}
			String terminal_name = sym.terminalNames[id];
			if (i == token_list.size() - 1){
				expected_tokens += terminal_name;
			}else{
				expected_tokens += terminal_name + " , ";
			}
		}
		System.err.println("Se esperaba alguno de los siguientes tokens:" + expected_tokens);
	};

	public void report_fatal_error(String message, Object info) {
		report_error(message, info);
		throw new RuntimeException("Fatal Syntax Error");
	}
:};

/*Declaracion de terminales y no terminales*/
/*Terminales*/
/*Comandos de consola*/
terminal WRITE, READ;

/*Tipos de datos*/
terminal ENTERO, REAL, BOOLEAN, CARACTER, CADENA, TYPE;

/*Declaracion de variables, visibilidad*/
terminal DIM, AS, PUBLIC, PRIVATE, NEW;

/*Comandos de funcion*/
terminal SUB, FUNCTION, EXIT, CALL, BYREF, BYVAL;

/*Operadores logicos*/
terminal OP_MAYOR_QUE, OP_MENOR_QUE, OP_MAYOR_IGUAL_QUE, OP_MENOR_IGUAL_QUE, OP_AND, OP_OR, OP_NOT;

/*Operadores aritmeticos*/
terminal OP_SUMA, OP_RESTA, OP_MULTIPLICACION, OP_DIVISION, OP_POTENCIA, OP_IGUAL;

/*Estructuras de control*/
terminal IF, THEN, ELSE, ELSE_IF, END, FOR, TO, STEP, NEXT, LOOP, DO, WHILE, UNTIL;

/*Otros*/
terminal COMA, PUNTO, FIN_LINEA, PAR_IZQ, PAR_DER;

/*Literales*/
terminal Integer ENTERO_LITERAL;
terminal Double REAL_LITERAL;
terminal Character CARACTER_LITERAL;
terminal String CADENA_LITERAL, IDENTIFICADOR;
terminal Boolean TRUE_LITERAL, FALSE_LITERAL;
terminal TYPE_LITERAL;

/*No terminales*/
non terminal inicio_programa;
non terminal sentencias_principales; 
non terminal sentencia_principal; 
non terminal declaracion_variables; 
non terminal declaracion_sub; 
non terminal declaracion_funcion;
non terminal declaracion_type;
non terminal cuerpo_funcion; 
non terminal sentencias_cuerpo_funcion; 
non terminal sentencia_cuerpo_funcion; 
non terminal sentencia_for_step; 
non terminal sentencia_do_while; 
non terminal sentencia_if;
non terminal sentencia_else_if;
non terminal sentencia_else; 
non terminal sentencia_consola; 
non terminal cuerpo_nuevo_tipo; 
non terminal sentencias_cuerpo_nuevo_tipo; 
non terminal declaracion_variables_nuevo_tipo;
non terminal parametros;
non terminal lista_parametros; 
non terminal forma_de_paso; 
non terminal sentencia_asignacion; 
non terminal receptor_asignacion; 
non terminal sentencia_llamado_funcion; 
non terminal llamado_funcion;
non terminal argumentos;
non terminal lista_argumentos; 
non terminal expresion; 
non terminal operador_aritmetico; 
non terminal operador_aritmetico_suma; 
non terminal operador_aritmetico_multiplicacion; 
non terminal operador_logico;
non terminal operador_relacional;
non terminal operador_negacion; 
non terminal operador_distinto; 
non terminal propiedad; 
non terminal cadena_propiedades; 
non terminal fin_linea; 
non terminal termino; 
non terminal tipo_dato;
non terminal visibilidad;
non terminal lista_variables;
non terminal tipos_step;

precedence left OP_OR;
precedence left OP_AND;
precedence left OP_SUMA, OP_RESTA;
precedence left OP_POTENCIA, OP_MULTIPLICACION, OP_DIVISION;
precedence left OP_MENOR_QUE, OP_MENOR_IGUAL_QUE, OP_MAYOR_QUE, OP_MAYOR_IGUAL_QUE, OP_IGUAL;

inicio_programa						::=	fin_linea sentencias_principales
										| sentencias_principales
										| ;

sentencias_principales				::=	sentencia_principal
										| sentencias_principales fin_linea sentencia_principal;

sentencia_principal 				::=	declaracion_variables
										| declaracion_sub
										| declaracion_funcion
										| declaracion_type;

/*TODO: Gramatica para Dim a, b, c As Integer*/
declaracion_variables				::=	visibilidad DIM lista_variables AS tipo_dato
										| visibilidad DIM error {:parser.report_error("declaracion_variables: Se esperaba IDENTIFICADOR", "\t");:} AS tipo_dato
										| visibilidad DIM lista_variables error {:parser.report_error("declaracion_variables: Se esperaba AS", "\t");:} tipo_dato
										| visibilidad DIM lista_variables AS NEW llamado_funcion;
										
declaracion_sub						::=	visibilidad SUB IDENTIFICADOR parametros fin_linea cuerpo_funcion END SUB
										| visibilidad SUB error{:parser.report_error("declaracion_sub: Se esperaba IDENTIFICADOR", "\t");:} parametros fin_linea cuerpo_funcion END SUB
										| visibilidad SUB IDENTIFICADOR parametros fin_linea cuerpo_funcion error{:parser.report_error("declaracion_sub: Se esperaba END", "\t");:} SUB
										| visibilidad SUB IDENTIFICADOR parametros fin_linea cuerpo_funcion END error{:parser.report_error("declaracion_sub: Se esperaba SUB", "\t");:};

declaracion_funcion					::=	visibilidad FUNCTION IDENTIFICADOR parametros fin_linea cuerpo_funcion END FUNCTION
										| visibilidad FUNCTION error{:parser.report_error("declaracion_funcion: Se esperaba IDENTIFICADOR", "\t");:} parametros fin_linea cuerpo_funcion END FUNCTION
										| visibilidad FUNCTION IDENTIFICADOR parametros error{:parser.report_error("declaracion_funcion: Se esperaba AS", "\t");:} tipo_dato fin_linea cuerpo_funcion END FUNCTION
										| visibilidad FUNCTION IDENTIFICADOR parametros fin_linea cuerpo_funcion error{:parser.report_error("declaracion_funcion: Se esperaba END", "\t");:} FUNCTION
										| visibilidad FUNCTION IDENTIFICADOR parametros fin_linea cuerpo_funcion END error{:parser.report_error("declaracion_funcion: Se esperaba FUNCTION", "\t");:};

declaracion_type					::=	visibilidad TYPE IDENTIFICADOR fin_linea cuerpo_nuevo_tipo END TYPE
										| visibilidad TYPE error{:parser.report_error("declaracion_type: Se esperaba IDENTIFICADOR", "\t");:} fin_linea cuerpo_nuevo_tipo END TYPE
										| visibilidad TYPE IDENTIFICADOR fin_linea cuerpo_nuevo_tipo error{:parser.report_error("declaracion_type: Se esperaba END", "\t");:} TYPE
										| visibilidad TYPE IDENTIFICADOR fin_linea cuerpo_nuevo_tipo END error{:parser.report_error("declaracion_type: Se esperaba TYPE", "\t");:};

cuerpo_funcion						::=	sentencias_cuerpo_funcion
										| ;

sentencias_cuerpo_funcion			::=	sentencia_cuerpo_funcion 
										| sentencias_cuerpo_funcion sentencia_cuerpo_funcion;

sentencia_cuerpo_funcion 			::=	propiedad argumentos fin_linea
										| declaracion_variables fin_linea
										| sentencia_for_step fin_linea
										| sentencia_do_while fin_linea
										| sentencia_if fin_linea
										| sentencia_consola fin_linea
										| sentencia_llamado_funcion fin_linea
										| sentencia_asignacion fin_linea;

sentencia_for_step					::=	FOR IDENTIFICADOR OP_IGUAL expresion TO expresion STEP tipos_step fin_linea cuerpo_funcion NEXT IDENTIFICADOR
										| FOR error{:parser.report_error("sentencia_for_step: Se esperaba IDENTIFICADOR", "\t");:} OP_IGUAL expresion TO expresion STEP tipos_step fin_linea cuerpo_funcion NEXT IDENTIFICADOR
										| FOR IDENTIFICADOR error{:parser.report_error("sentencia_for_step: Se esperaba OP_IGUAL", "\t");:} expresion TO expresion STEP tipos_step fin_linea cuerpo_funcion NEXT IDENTIFICADOR
										| FOR IDENTIFICADOR OP_IGUAL expresion error{:parser.report_error("sentencia_for_step: Se esperaba TO", "\t");:} expresion STEP tipos_step fin_linea cuerpo_funcion NEXT IDENTIFICADOR
										| FOR IDENTIFICADOR OP_IGUAL expresion TO expresion error{:parser.report_error("sentencia_for_step: Se esperaba STEP", "\t");:} tipos_step fin_linea cuerpo_funcion NEXT IDENTIFICADOR
										| FOR IDENTIFICADOR OP_IGUAL expresion TO expresion STEP error{:parser.report_error("sentencia_for_step: Se esperaba tipos_step", "\t");:} fin_linea cuerpo_funcion NEXT IDENTIFICADOR
										| FOR IDENTIFICADOR OP_IGUAL expresion TO expresion STEP tipos_step fin_linea cuerpo_funcion error{:parser.report_error("sentencia_for_step: Se esperaba NEXT", "\t");:} IDENTIFICADOR
										| FOR IDENTIFICADOR OP_IGUAL expresion TO expresion STEP tipos_step fin_linea cuerpo_funcion NEXT error{:parser.report_error("sentencia_for_step: Se esperaba IDENTIFICADOR", "\t");:};

/*TODO: Agregar DO LOOP UNTIL expresion*/
sentencia_do_while					::=	DO WHILE expresion fin_linea cuerpo_funcion LOOP
										| DO error{:parser.report_error("sentencia_do_while: Se esperaba WHILE", "\t");:} expresion fin_linea cuerpo_funcion LOOP
										| DO WHILE expresion fin_linea cuerpo_funcion error{:parser.report_error("sentencia_do_while: Se esperaba LOOP", "\t");:};

sentencia_if 						::=	IF expresion THEN fin_linea cuerpo_funcion sentencia_else_if sentencia_else END IF
										| IF expresion error{:parser.report_error("sentencia_if: Se esperaba THEN", "\t");:} fin_linea cuerpo_funcion sentencia_else_if sentencia_else END IF
										| IF expresion THEN fin_linea cuerpo_funcion sentencia_else_if sentencia_else error{:parser.report_error("sentencia_if: Se esperaba END", "\t");:} IF
										| IF expresion THEN fin_linea cuerpo_funcion sentencia_else_if sentencia_else_if END error{:parser.report_error("sentencia_if: Se esperaba IF", "\t");:}
										| IF expresion THEN fin_linea cuerpo_funcion END IF
										| IF expresion THEN fin_linea cuerpo_funcion sentencia_else END IF;

sentencia_else_if					::=	ELSE_IF expresion THEN fin_linea cuerpo_funcion sentencia_else_if
										| ELSE_IF expresion error{:parser.report_error("sentencia_else_if: Se esperaba THEN", "\t");:} fin_linea cuerpo_funcion sentencia_else_if
										| ELSE_IF expresion THEN fin_linea cuerpo_funcion error{:parser.report_error("sentencia_else_if: Se esperaba sentencia_else_if", "\t");:}/*
										| */;

sentencia_else 						::=	ELSE fin_linea cuerpo_funcion/*
										| */;

sentencia_consola					::=	WRITE PAR_IZQ termino PAR_DER
										| WRITE error{:parser.report_error("sentencia_consola WRITE: Se esperaba \"(\"", "\t");:} PAR_DER
										| WRITE PAR_IZQ termino error{:parser.report_error("sentencia_consola WRITE: Se esperaba \")\"", "\t");:}
										| READ PAR_IZQ termino PAR_DER
										| READ error{:parser.report_error("sentencia_consola READ: Se esperaba \"(\"", "\t");:} termino PAR_DER
										| READ PAR_IZQ termino error{:parser.report_error("sentencia_consola READ: Se esperaba \")\"", "\t");:};

cuerpo_nuevo_tipo					::=	sentencias_cuerpo_nuevo_tipo
										| ;

sentencias_cuerpo_nuevo_tipo		::=	declaracion_variables_nuevo_tipo fin_linea
										| sentencias_cuerpo_nuevo_tipo declaracion_variables_nuevo_tipo;

declaracion_variables_nuevo_tipo	::=	IDENTIFICADOR AS tipo_dato;

parametros							::=	PAR_IZQ PAR_DER
										| PAR_IZQ error{:parser.report_error("parametros: Se esperaba \")\"", "\t");:}
										| PAR_IZQ lista_parametros PAR_DER
										| PAR_IZQ lista_parametros error{:parser.report_error("parametros: Se esperaba \")\"", "\t");:};

lista_parametros					::=	IDENTIFICADOR AS tipo_dato
										| forma_de_paso IDENTIFICADOR AS tipo_dato
										| forma_de_paso error{:parser.report_error("lista_parametros: Se esperaba IDENTIFICADOR", "\t");:} AS tipo_dato
										| forma_de_paso IDENTIFICADOR error{:parser.report_error("lista_parametros: Se esperaba AS", "\t");:} tipo_dato
										| lista_parametros COMA forma_de_paso IDENTIFICADOR AS tipo_dato
										| lista_parametros error{:parser.report_error("lista_parametros: Se esperaba COMA", "\t");:} forma_de_paso IDENTIFICADOR AS tipo_dato
										| lista_parametros COMA forma_de_paso error{:parser.report_error("lista_parametros: Se esperaba IDENTIFICADOR", "\t");:} AS tipo_dato
										| lista_parametros COMA forma_de_paso IDENTIFICADOR error{:parser.report_error("lista_parametros: Se esperaba AS", "\t");:} tipo_dato;

forma_de_paso 						::=	BYVAL
										| BYREF;

sentencia_asignacion				::=	receptor_asignacion OP_IGUAL expresion
										| expresion OP_IGUAL expresion;

receptor_asignacion					::=	IDENTIFICADOR
										| propiedad;

sentencia_llamado_funcion			::=	CALL llamado_funcion
										| CALL error{:parser.report_error("Sentencia llamado funcion: Se esperaba el llamado a la funcion", "\t");:};

llamado_funcion 					::=	IDENTIFICADOR argumentos;

argumentos							::=	PAR_IZQ PAR_DER
										| PAR_IZQ error{:parser.report_error("Argumentos: Se esperaba \")\"", "\t");:}
										| PAR_IZQ lista_argumentos PAR_DER
										| PAR_IZQ lista_argumentos error{:parser.report_error("Argumentos: Se esperaba \")\"", "\t");:};

lista_argumentos					::=	expresion
										| expresion COMA lista_argumentos;

expresion							::=	expresion operador_aritmetico expresion
										| expresion operador_relacional expresion
										| expresion operador_logico expresion
										| PAR_IZQ expresion PAR_DER
										| OP_NOT expresion
										| operador_negacion expresion
										| termino;

operador_aritmetico					::=	operador_aritmetico_suma
										| operador_aritmetico_multiplicacion;

operador_aritmetico_suma			::=	OP_SUMA
										| OP_RESTA;

operador_aritmetico_multiplicacion	::=	OP_POTENCIA
										| OP_MULTIPLICACION
										| OP_DIVISION;

operador_relacional					::=	OP_MAYOR_QUE
										| OP_MENOR_QUE
										| OP_MAYOR_IGUAL_QUE
										| OP_MENOR_IGUAL_QUE
										| operador_distinto;

operador_logico						::=	OP_AND
										| OP_OR;

operador_negacion					::=	OP_RESTA;

operador_distinto					::=	OP_MENOR_QUE OP_MAYOR_QUE
										| OP_MENOR_QUE error{:parser.report_error("operador_distinto: Se esperaba OP_MAYOR_QUE", "\t");:};

propiedad							::=	IDENTIFICADOR cadena_propiedades;

cadena_propiedades					::=	PUNTO IDENTIFICADOR
										| PUNTO IDENTIFICADOR cadena_propiedades;

fin_linea 							::=	FIN_LINEA fin_linea
										| FIN_LINEA;

termino								::=	receptor_asignacion
										| ENTERO_LITERAL
										| REAL_LITERAL
										| CARACTER_LITERAL
										| CADENA_LITERAL
										| TRUE_LITERAL
										| FALSE_LITERAL
										| llamado_funcion;

tipo_dato							::=	ENTERO
										| REAL
										| CADENA
										| CARACTER
										| BOOLEAN
										| IDENTIFICADOR /*Puede ser un nuevo tipo de dato*/;

visibilidad							::=	PUBLIC
										| PRIVATE
										| ;

lista_variables						::= IDENTIFICADOR
										| IDENTIFICADOR COMA lista_variables
										| IDENTIFICADOR COMA error{:parser.report_error("lista_variables: Se esperaba lista_variables", "\t");:};

tipos_step						::= ENTERO_LITERAL
										| REAL_LITERAL;