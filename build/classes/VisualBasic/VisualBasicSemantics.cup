package VisualBasic;

import java.io.File;
import java.util.List;
import java.util.Stack;
import java.util.Arrays;
import abstractSyntaxTree.AST;
import symbolTable.*;

action code{:
	AST ast = new AST();
	Stack<SymbolTable> scopes = new Stack();
	SymbolTable current_scope = new SymbolTable("global");

	Stack<Integer> offsets = new Stack();
	int current_offset = 0;

	public void printScopeStack() {
		String values = Arrays.toString(scopes.toArray());
		System.out.println(values);
	}
:}

parser code {:
	@Override
	public void report_error(String message, Object info) {
		// if (!((Symbol)info).value.toString().equals("null")){
			if (info instanceof String)
				System.err.println(" " + info + " " + message + "\n");
			else {
				StringBuffer m = new StringBuffer("Error ");
				if (info instanceof java_cup.runtime.Symbol) {
					m.append(("(Se ha encontrado el token \"" + ((java_cup.runtime.Symbol)info).value + "\" en la linea "
						+ ((java_cup.runtime.Symbol)info).left + 1 + ", columna " + ((java_cup.runtime.Symbol)info).right + 1) + ")");
				}
				if (message.equals("Couldn't repair and continue parse"))
					m.append(" : No existe una regla por los momentos para este token.");
				else
					m.append(" : " + message);
				System.err.println(m);
			}
		// }
	}
	@Override
	public void syntax_error(java_cup.runtime.Symbol s){
		System.err.println( "(Se ha encontrado el token \"" + sym.terminalNames[s.sym] + "\" en la linea " + (s.left+1) + ", columna" + (s.right+1) + ")" ); 
        expected();
	}

	public void expected(){
		List<Integer> token_list = this.expected_token_ids();
		if (token_list.size() <= 0){
			token_list = this.expected_token_ids();
		}
		String expected_tokens = "";
		for (int i = 0 ; i < token_list.size(); i++){
			int id = token_list.get(i);
			if (id == 1){
				continue;
			}
			String terminal_name = sym.terminalNames[id];
			if (i == token_list.size() - 1){
				expected_tokens += terminal_name;
			}else{
				expected_tokens += terminal_name + " , ";
			}
		}
		System.err.println("Se esperaba alguno de los siguientes tokens:" + expected_tokens);
	};

	public void report_fatal_error(String message, Object info) {
		report_error(message, info);
		throw new RuntimeException("Fatal Syntax Error");
	}
:};

/*Declaracion de terminales y no terminales*/
/*Terminales*/
/*Comandos de consola*/
terminal WRITE, READ;

/*Tipos de datos*/
terminal ENTERO, REAL, BOOLEAN, CARACTER, CADENA, TYPE;

/*Declaracion de variables, visibilidad*/
terminal DIM, AS, PUBLIC, PRIVATE, NEW;

/*Comandos de funcion*/
terminal SUB, FUNCTION, EXIT, CALL, BYREF, BYVAL;

/*Operadores logicos*/
terminal OP_MAYOR_QUE, OP_MENOR_QUE, OP_MAYOR_IGUAL_QUE, OP_MENOR_IGUAL_QUE, OP_AND, OP_OR, OP_NOT;

/*Operadores aritmeticos*/
terminal OP_SUMA, OP_RESTA, OP_MULTIPLICACION, OP_DIVISION, OP_POTENCIA, OP_IGUAL;

/*Estructuras de control*/
terminal IF, THEN, ELSE, ELSE_IF, END, FOR, TO, STEP, NEXT, LOOP, DO, WHILE, UNTIL;

/*Otros*/
terminal COMA, PUNTO, FIN_LINEA, PAR_IZQ, PAR_DER;

/*Literales*/
terminal Integer ENTERO_LITERAL;
terminal Double REAL_LITERAL;
terminal Character CARACTER_LITERAL;
terminal String CADENA_LITERAL, IDENTIFICADOR;
terminal Boolean TRUE_LITERAL, FALSE_LITERAL;
terminal TYPE_LITERAL;

/*No terminales*/
non terminal AST.Programa inicio_programa;
non terminal AST.SentenciasPrincipales sentencias_principales; 
non terminal AST.SentenciaPrincipal sentencia_principal; 
non terminal AST.DeclaracionVariables declaracion_variables; 
non terminal AST.DeclaracionSub declaracion_sub; 
non terminal AST.DeclaracionFuncion declaracion_funcion;
non terminal AST.DeclaracionType declaracion_type;
non terminal AST.CuerpoFuncion cuerpo_funcion; 
non terminal AST.SentenciasCuerpoFuncion sentencias_cuerpo_funcion; 
non terminal AST.SentenciaCuerpoFuncion sentencia_cuerpo_funcion; 
non terminal AST.SentenciaForStep sentencia_for_step; 
non terminal AST.SentenciaDoWhile sentencia_do_while; 
non terminal AST.SentenciaIf sentencia_if;
non terminal AST.SentenciasElseIf sentencias_else_if;
non terminal AST.SentenciaElseIf sentencia_else_if;
non terminal AST.SentenciaElse sentencia_else; 
non terminal AST.SentenciaConsola sentencia_consola; 
non terminal AST.CuerpoNuevoTipo cuerpo_nuevo_tipo; 
non terminal AST.SentenciasCuerpoNuevoTipo sentencias_cuerpo_nuevo_tipo; 
non terminal AST.DeclaracionVariablesNuevoTipo declaracion_variables_nuevo_tipo;
non terminal AST.Parametros parametros;
non terminal AST.ListaParametros lista_parametros; 
non terminal AST.FormaPaso forma_de_paso; 
non terminal AST.SentenciaAsignacion sentencia_asignacion; 
non terminal AST.ReceptorAsignacion receptor_asignacion; 
non terminal AST.SentenciaLlamadoFuncion sentencia_llamado_funcion; 
non terminal AST.LlamadoFuncion llamado_funcion;
non terminal AST.Argumentos argumentos;
non terminal AST.ListaArgumentos lista_argumentos; 
non terminal AST.Expresion expresion; 
non terminal String operador_aritmetico; 
non terminal String operador_aritmetico_suma; 
non terminal String operador_aritmetico_multiplicacion; 
non terminal String operador_logico;
non terminal String operador_relacional;
non terminal String operador_negacion; 
non terminal String operador_distinto; 
non terminal AST.Propiedad propiedad; 
non terminal AST.CadenaPropiedades cadena_propiedades; 
non terminal fin_linea; 
non terminal AST.Termino termino; 
non terminal AST.TipoDato tipo_dato;
non terminal AST.Visibilidad visibilidad;
// non terminal AST.ListaVariables lista_variables;
non terminal String tipos_step;

precedence left OP_OR;
precedence left OP_AND;
precedence left OP_SUMA, OP_RESTA;
precedence left OP_POTENCIA, OP_MULTIPLICACION, OP_DIVISION;
precedence left OP_MENOR_QUE, OP_MENOR_IGUAL_QUE, OP_MAYOR_QUE, OP_MAYOR_IGUAL_QUE, OP_IGUAL;

inicio_programa						::=	fin_linea sentencias_principales:sp
										{:	
											System.out.println("\n" + current_scope.toString());
											RESULT = ast.new Programa(sp);
										:}

										| sentencias_principales:sp
										{:	
											System.out.println("\n" + current_scope.toString());
											RESULT = ast.new Programa(sp);
										:}

										| ;

sentencias_principales				::=	sentencia_principal:sp
										{:	RESULT = ast.new SentenciasPrincipales();
											RESULT.add(sp);:}

										| sentencias_principales:ssp fin_linea sentencia_principal:sp
										{:	RESULT = ast.new SentenciasPrincipales();
											for (int i = 0; i < ssp.size(); i++)
												RESULT.add(ssp.getAt(i));
											RESULT.add(sp);:};

sentencia_principal 				::=	declaracion_variables:dv
										{:	RESULT = dv;:}

										| declaracion_sub:ds 
										{:	RESULT = ds;:}
										
										| declaracion_funcion:df
										{:	RESULT = df;:}
										
										| declaracion_type:dt
										{:	RESULT = dt;:};

/*TODO: Gramatica para Dim a, b, c As Integer*/
declaracion_variables				::=	visibilidad:v DIM IDENTIFICADOR:id AS tipo_dato:td
										{:	
											if (td.getTipoDato().equals("Integer"))
												current_scope.add(id, new Symbol(new IntegerType(id)));
											else if (td.getTipoDato().equals("Double"))
												current_scope.add(id, new Symbol(new DoubleType(id)));
											else if (td.getTipoDato().equals("Character"))
												current_scope.add(id, new Symbol(new CharacterType(id)));
											else if (td.getTipoDato().equals("Boolean"))
												current_scope.add(id, new Symbol(new BooleanType(id)));

											RESULT = ast.new DeclaracionVariables(v, id, td);
										:}
										
										| visibilidad:v DIM IDENTIFICADOR:lv AS NEW llamado_funcion:lf
										{:	RESULT = ast.new DeclaracionVariables(v, lv, lf);:};
										
declaracion_sub						::=	visibilidad:v SUB IDENTIFICADOR:id parametros:p 
										{:	
											SymbolTable sub_scope = new SymbolTable(current_scope, id);
											scopes.push(current_scope);
											current_scope = sub_scope;

											System.out.println("\nCAMBIO DE AMBITO (" + id + ")");
											
											offsets.push(current_offset);
											current_offset = 0;

											for (int i = 0; i < p.size(); i++) {
												AST.Parametro param = p.getListaParametros().getAt(i);
												if (param.getTipoDato().equals("Integer"))
													current_scope.add(param.getId(), new Symbol(new IntegerType(param.getId())));
												else if (param.getTipoDato().equals("Double"))
													current_scope.add(param.getId(), new Symbol(new DoubleType(param.getId())));
												else if (param.getTipoDato().equals("Character"))
													current_scope.add(param.getId(), new Symbol(new CharacterType(param.getId())));
												else if (param.getTipoDato().equals("Boolean"))
													current_scope.add(param.getId(), new Symbol(new BooleanType(param.getId())));
											}
										:}
										fin_linea cuerpo_funcion:cf END SUB
										{:	
											System.out.println(current_scope.toString());
											current_scope = scopes.pop();
											current_offset = offsets.pop();
											RESULT = ast.new DeclaracionSub(v, p, cf);
										:};

declaracion_funcion					::=	visibilidad:v FUNCTION IDENTIFICADOR:id parametros:p 
										{:
											SymbolTable function_scope = new SymbolTable(current_scope, id);
											scopes.push(current_scope);
											current_scope = function_scope;

											System.out.println("\nCAMBIO DE AMBITO (" + id + ")");

											offsets.push(current_offset);
											current_offset = 0;

											for (int i = 0; i < p.size(); i++) {
												AST.Parametro param = p.getListaParametros().getAt(i);
												if (param.getTipoDato().equals("Integer"))
													current_scope.add(param.getId(), new Symbol(new IntegerType(param.getId())));
												else if (param.getTipoDato().equals("Double"))
													current_scope.add(param.getId(), new Symbol(new DoubleType(param.getId())));
												else if (param.getTipoDato().equals("Character"))
													current_scope.add(param.getId(), new Symbol(new CharacterType(param.getId())));
												else if (param.getTipoDato().equals("Boolean"))
													current_scope.add(param.getId(), new Symbol(new BooleanType(param.getId())));
											}
										:}
										fin_linea cuerpo_funcion:cf END FUNCTION
										{:	
											System.out.println(current_scope.toString());
											current_scope = scopes.pop();
											current_offset = offsets.pop();
											RESULT = ast.new DeclaracionFuncion(v, p, cf);
										:};

declaracion_type					::=	visibilidad:v TYPE IDENTIFICADOR:id 
										{::}
										fin_linea cuerpo_nuevo_tipo:cnt END TYPE
										{:	RESULT = ast.new DeclaracionType(v, id, cnt);:};

cuerpo_funcion						::=	sentencias_cuerpo_funcion:scf
										{:	RESULT = ast.new CuerpoFuncion(scf);:}

										| ;

sentencias_cuerpo_funcion			::=	sentencia_cuerpo_funcion:scf
										{:	RESULT = ast.new SentenciasCuerpoFuncion();
											RESULT.add(scf);:}

										| sentencias_cuerpo_funcion:sscf sentencia_cuerpo_funcion:scf
										{:	RESULT = ast.new SentenciasCuerpoFuncion();
											for (int i = 0; i < sscf.size(); i++)
												RESULT.add(sscf.getAt(i));
											RESULT.add(scf);:};

sentencia_cuerpo_funcion 			::=	propiedad:p argumentos:a fin_linea
										{:	RESULT = ast.new SentenciaLlamadoFuncionPropiedad(p, a);:}

										| DIM IDENTIFICADOR:id AS tipo_dato:td fin_linea
										{:
											if (td.getTipoDato().equals("Integer"))
												current_scope.add(id, new Symbol(new IntegerType(id)));
											else if (td.getTipoDato().equals("Double"))
												current_scope.add(id, new Symbol(new DoubleType(id)));
											else if (td.getTipoDato().equals("Character"))
												current_scope.add(id, new Symbol(new CharacterType(id)));
											else if (td.getTipoDato().equals("Boolean"))
												current_scope.add(id, new Symbol(new BooleanType(id)));

											RESULT = ast.new DeclaracionVariablesCuerpoFuncion(id, td);
										:}
										
										| DIM IDENTIFICADOR:id AS NEW llamado_funcion:lf fin_linea
										{:	
											current_scope.add(id, new Symbol(new TypeType(lf.getId())));
											RESULT = ast.new DeclaracionVariablesCuerpoFuncion(id, lf);
										:}

										| sentencia_for_step:sft fin_linea
										{:	RESULT = sft;:}

										| sentencia_do_while:sdw fin_linea
										{:	RESULT = sdw;:}

										| sentencia_if:si fin_linea
										{:	RESULT = si;:}

										| sentencia_consola:sc fin_linea
										{:	RESULT = sc;:}

										| sentencia_llamado_funcion:slf fin_linea
										{:	RESULT = slf;:}

										| sentencia_asignacion:sa fin_linea
										{:	RESULT = sa;:};

sentencia_for_step					::=	FOR IDENTIFICADOR:id OP_IGUAL expresion:e1 TO expresion:e2 STEP tipos_step:ts fin_linea cuerpo_funcion:cf NEXT IDENTIFICADOR
										{:	RESULT = ast.new SentenciaForStep(id, e1, e2, ts, cf);:}

										| FOR error{:parser.report_error("sentencia_for_step: Se esperaba IDENTIFICADOR", "\t");:} OP_IGUAL expresion TO expresion STEP tipos_step fin_linea cuerpo_funcion NEXT IDENTIFICADOR
										| FOR IDENTIFICADOR error{:parser.report_error("sentencia_for_step: Se esperaba OP_IGUAL", "\t");:} expresion TO expresion STEP tipos_step fin_linea cuerpo_funcion NEXT IDENTIFICADOR
										| FOR IDENTIFICADOR OP_IGUAL expresion error{:parser.report_error("sentencia_for_step: Se esperaba TO", "\t");:} expresion STEP tipos_step fin_linea cuerpo_funcion NEXT IDENTIFICADOR
										| FOR IDENTIFICADOR OP_IGUAL expresion TO expresion error{:parser.report_error("sentencia_for_step: Se esperaba STEP", "\t");:} tipos_step fin_linea cuerpo_funcion NEXT IDENTIFICADOR
										| FOR IDENTIFICADOR OP_IGUAL expresion TO expresion STEP error{:parser.report_error("sentencia_for_step: Se esperaba tipos_step", "\t");:} fin_linea cuerpo_funcion NEXT IDENTIFICADOR
										| FOR IDENTIFICADOR OP_IGUAL expresion TO expresion STEP tipos_step fin_linea cuerpo_funcion error{:parser.report_error("sentencia_for_step: Se esperaba NEXT", "\t");:} IDENTIFICADOR
										| FOR IDENTIFICADOR OP_IGUAL expresion TO expresion STEP tipos_step fin_linea cuerpo_funcion NEXT error{:parser.report_error("sentencia_for_step: Se esperaba IDENTIFICADOR", "\t");:};

/*TODO: Agregar DO LOOP UNTIL expresion*/
sentencia_do_while					::=	DO WHILE expresion:e fin_linea cuerpo_funcion:cf LOOP
										{:	RESULT = ast.new SentenciaDoWhile(e, cf);:}

										| DO error{:parser.report_error("sentencia_do_while: Se esperaba WHILE", "\t");:} expresion fin_linea cuerpo_funcion LOOP
										| DO WHILE error{:parser.report_error("sentencia_do_while: Se esperaba expresion", "\t");:} fin_linea cuerpo_funcion LOOP
										| DO WHILE expresion error{:parser.report_error("sentencia_do_while: Se esperaba fin_linea", "\t");:} cuerpo_funcion LOOP
										| DO WHILE expresion fin_linea cuerpo_funcion error{:parser.report_error("sentencia_do_while: Se esperaba LOOP", "\t");:};

sentencia_if 						::=	IF expresion:e THEN fin_linea cuerpo_funcion:cf sentencias_else_if:ssei sentencia_else:se END IF
										{:	RESULT = ast.new SentenciaIf(e, cf, ssei, se);:}

										| IF expresion error{:parser.report_error("sentencia_if: Se esperaba THEN", "\t");:} fin_linea cuerpo_funcion sentencia_else_if sentencia_else END IF
										| IF expresion THEN fin_linea cuerpo_funcion sentencias_else_if sentencia_else error{:parser.report_error("sentencia_if: Se esperaba END", "\t");:} IF
										| IF expresion THEN fin_linea cuerpo_funcion sentencias_else_if sentencia_else END error{:parser.report_error("sentencia_if: Se esperaba IF", "\t");:}
										| IF expresion:e THEN fin_linea cuerpo_funcion:cf END IF
										{:	RESULT = ast.new SentenciaIf(e, cf);:}

										| IF expresion THEN fin_linea cuerpo_funcion error{:parser.report_error("sentencia_if: Se esperaba END", "\t");:} IF
										| IF expresion THEN fin_linea cuerpo_funcion END error{:parser.report_error("sentencia_if: Se esperaba IF", "\t");:}
										| IF expresion:e THEN fin_linea cuerpo_funcion:cf sentencia_else:se END IF
										{:	RESULT = ast.new SentenciaIf(e, cf, se);:};

sentencias_else_if					::= sentencia_else_if:sei
										{:	RESULT = ast.new SentenciasElseIf();
											RESULT.add(sei);:}

										| sentencias_else_if:ssei sentencia_else_if:sei
										{:	ssei.add(sei);:};

sentencia_else_if					::=	ELSE_IF expresion:e THEN fin_linea cuerpo_funcion:cf 
										{:	RESULT = ast.new SentenciaElseIf(e, cf);:};

sentencia_else 						::=	ELSE fin_linea cuerpo_funcion:cf
										{:	RESULT = ast.new SentenciaElse(cf);:};

sentencia_consola					::=	WRITE PAR_IZQ PAR_DER
										{:	RESULT = ast.new SentenciaConsola("Console.Write", ast.new Termino(""));:}

										| WRITE PAR_IZQ termino:t PAR_DER
										{:	RESULT = ast.new SentenciaConsola("Console.Write", t);:}

										| WRITE error{:parser.report_error("sentencia_consola WRITE: Se esperaba \"(\"", "\t");:} PAR_DER
										| WRITE PAR_IZQ termino error{:parser.report_error("sentencia_consola WRITE: Se esperaba \")\"", "\t");:}
										| READ PAR_IZQ termino:t PAR_DER
										{:	RESULT = ast.new SentenciaConsola("Console.In", t);:}

										| READ PAR_IZQ PAR_DER
										{:	RESULT = ast.new SentenciaConsola("Console.In", ast.new Termino(""));:}

										| READ error{:parser.report_error("sentencia_consola READ: Se esperaba \"(\"", "\t");:} termino PAR_DER
										| READ PAR_IZQ termino error{:parser.report_error("sentencia_consola READ: Se esperaba \")\"", "\t");:};

cuerpo_nuevo_tipo					::=	sentencias_cuerpo_nuevo_tipo:scnt
										{:	RESULT = ast.new CuerpoNuevoTipo(scnt);:}

										| ;

sentencias_cuerpo_nuevo_tipo		::=	declaracion_variables_nuevo_tipo:dvnt fin_linea
										{:	RESULT = ast.new SentenciasCuerpoNuevoTipo();
											RESULT.add(dvnt);:}

										| sentencias_cuerpo_nuevo_tipo:sscnt declaracion_variables_nuevo_tipo:dvnt fin_linea
										{:	RESULT = ast.new SentenciasCuerpoNuevoTipo();
											for (int i = 0; i < sscnt.size(); i++) {
												RESULT.add(sscnt.getAt(i));
											}
											RESULT.add(dvnt);:};

declaracion_variables_nuevo_tipo	::=	IDENTIFICADOR:id AS tipo_dato:td
										{:	
											if (td.getTipoDato().equals("Integer"))
												current_scope.add(id, new Symbol(new IntegerType(id)));
											else if (td.getTipoDato().equals("Double"))
												current_scope.add(id, new Symbol(new DoubleType(id)));
											else if (td.getTipoDato().equals("Character"))
												current_scope.add(id, new Symbol(new CharacterType(id)));
											else if (td.getTipoDato().equals("Boolean"))
												current_scope.add(id, new Symbol(new BooleanType(id)));


											RESULT = ast.new DeclaracionVariablesNuevoTipo(id, td);
										:};

parametros							::=	PAR_IZQ PAR_DER
										{:	RESULT = ast.new Parametros();:}

										| PAR_IZQ error{:parser.report_error("parametros: Se esperaba \")\"", "\t");:}
										| PAR_IZQ lista_parametros:lp PAR_DER
										{:	RESULT = ast.new Parametros(lp);:}

										| PAR_IZQ lista_parametros error{:parser.report_error("parametros: Se esperaba \")\"", "\t");:};

lista_parametros					::=	IDENTIFICADOR:id AS tipo_dato:td
										{:	RESULT = ast.new ListaParametros();
											RESULT.add(ast.new Parametro(id, td));:}

										| forma_de_paso:fp IDENTIFICADOR:id AS tipo_dato:td
										{:	RESULT = ast.new ListaParametros();
											RESULT.add(ast.new Parametro(fp, id, td));:}

										| forma_de_paso error{:parser.report_error("lista_parametros: Se esperaba IDENTIFICADOR", "\t");:} AS tipo_dato
										| forma_de_paso IDENTIFICADOR error{:parser.report_error("lista_parametros: Se esperaba AS", "\t");:} tipo_dato
										| lista_parametros:lp COMA forma_de_paso:fp IDENTIFICADOR:id AS tipo_dato:td
										{:	RESULT = ast.new ListaParametros();
											for (int i = 0; i < lp.size(); i++) {
												RESULT.add(lp.getAt(i));
											}
											RESULT.add(ast.new Parametro(fp, id, td));:}

										| lista_parametros error{:parser.report_error("lista_parametros: Se esperaba COMA", "\t");:} forma_de_paso IDENTIFICADOR AS tipo_dato
										| lista_parametros COMA forma_de_paso error{:parser.report_error("lista_parametros: Se esperaba IDENTIFICADOR", "\t");:} AS tipo_dato
										| lista_parametros COMA forma_de_paso IDENTIFICADOR error{:parser.report_error("lista_parametros: Se esperaba AS", "\t");:} tipo_dato;

forma_de_paso 						::=	BYVAL
										{:	RESULT = ast.new FormaPaso("ByVal");:}

										| BYREF
										{:	RESULT = ast.new FormaPaso("ByRef");:};

sentencia_asignacion				::=	receptor_asignacion:ra OP_IGUAL expresion:e
										{:	RESULT = ast.new SentenciaAsignacion(ra, e);:}

										| receptor_asignacion:ra OP_IGUAL sentencia_consola:sc
										{:	RESULT = ast.new SentenciaAsignacion(ra, sc);:}

										| expresion:e1 OP_IGUAL expresion:e2
										{:	RESULT = ast.new SentenciaAsignacion(e1, e2);:};

receptor_asignacion					::=	IDENTIFICADOR:id
										{:	
											if (current_scope.get(id) == null)
												System.out.println("La variable " + id + " no ha sido declarada.");
											RESULT = ast.new ReceptorAsignacion(id);
										:}
										
										| propiedad:p
										{:	RESULT = ast.new ReceptorAsignacion(p);:};

sentencia_llamado_funcion			::=	CALL llamado_funcion:lf
										{:	RESULT = ast.new SentenciaLlamadoFuncion(lf);:}

										| CALL error{:parser.report_error("Sentencia llamado funcion: Se esperaba el llamado a la funcion", "\t");:};

llamado_funcion 					::=	IDENTIFICADOR:id argumentos:a
										{:	RESULT = ast.new LlamadoFuncion(id, a);:};

argumentos							::=	PAR_IZQ PAR_DER
										{:	RESULT = ast.new Argumentos();:}

										| PAR_IZQ error{:parser.report_error("Argumentos: Se esperaba \")\"", "\t");:}
										| PAR_IZQ lista_argumentos:la PAR_DER
										{:	RESULT = ast.new Argumentos(la);:}

										| PAR_IZQ lista_argumentos error{:parser.report_error("Argumentos: Se esperaba \")\"", "\t");:};

lista_argumentos					::=	expresion:e
										{:	RESULT = ast.new ListaArgumentos();
											RESULT.add(e);:}

										| lista_argumentos:la COMA expresion:e
										{:	RESULT = ast.new ListaArgumentos();
											for (int i = 0; i < la.size(); i++) {
												RESULT.add(la.getAt(i));
											}
											RESULT.add(e);:};

expresion							::=	expresion:e1 operador_aritmetico:o expresion:e2
										{:	RESULT = ast.new Expresion(e1, o, e2);:}

										| expresion:e1 operador_relacional:o expresion:e2
										{:	RESULT = ast.new Expresion(e1, o, e2);:}

										| expresion:e1 operador_logico:o expresion:e2
										{:	RESULT = ast.new Expresion(e1, o, e2);:}

										| PAR_IZQ expresion:e PAR_DER
										{:	RESULT = ast.new Expresion(e);:}

										| OP_NOT:o expresion:e
										{:	RESULT = ast.new Expresion(e, "<>");:}

										| operador_negacion:o expresion:e
										{:	RESULT = ast.new Expresion(e, o);:}

										| termino:t
										{:	RESULT = ast.new Expresion(t);:};

operador_aritmetico					::=	operador_aritmetico_suma:o
										{:	RESULT = o;:}

										| operador_aritmetico_multiplicacion:o
										{:	RESULT = o;:};

operador_aritmetico_suma			::=	OP_SUMA
										{:	RESULT = "+";:}

										| OP_RESTA
										{:	RESULT = "-";:};

operador_aritmetico_multiplicacion	::=	OP_POTENCIA
										{:	RESULT = "^";:}

										| OP_MULTIPLICACION
										{:	RESULT = "*";:}

										| OP_DIVISION
										{:	RESULT = "/";:};

operador_relacional					::=	OP_MAYOR_QUE
										{: RESULT = ">";:}

										| OP_MENOR_QUE
										{: RESULT = "<";:}

										| OP_MAYOR_IGUAL_QUE
										{: RESULT = ">=";:}

										| OP_MENOR_IGUAL_QUE
										{: RESULT = "<=";:}

										| OP_IGUAL
										{:	RESULT = "=";:}

										| operador_distinto:o
										{: RESULT = o;:};

operador_logico						::=	OP_AND
										{: RESULT = "And";:}

										| OP_OR
										{: RESULT = "Or";:};

operador_negacion					::=	OP_RESTA
										{: RESULT = "-";:};

operador_distinto					::=	OP_MENOR_QUE OP_MAYOR_QUE
										{: RESULT = "<>";:}

										| OP_MENOR_QUE error{:parser.report_error("operador_distinto: Se esperaba OP_MAYOR_QUE", "\t");:};

propiedad							::=	IDENTIFICADOR:id cadena_propiedades:cp
										{: RESULT = ast.new Propiedad(cp, id);:};

cadena_propiedades					::=	PUNTO IDENTIFICADOR:id
										{: RESULT = ast.new CadenaPropiedades();
											RESULT.add(id);:}

										| cadena_propiedades:cp PUNTO IDENTIFICADOR:id
										{: RESULT = ast.new CadenaPropiedades();
											for (int i = 0; i < cp.size(); i++) {
												RESULT.add(cp.getAt(i));
											}
											RESULT.add(id);:};

fin_linea 							::=	FIN_LINEA fin_linea
										| FIN_LINEA;

termino								::=	receptor_asignacion:ra
										{: RESULT = ast.new Termino(ra);:}

										| ENTERO_LITERAL:n
										{:	RESULT = ast.new Termino(Integer.toString(n));:}

										| REAL_LITERAL:n
										{:	RESULT = ast.new Termino(Double.toString(n));:}

										| CARACTER_LITERAL:n
										{: RESULT = ast.new Termino(Character.toString(n));:}

										| CADENA_LITERAL:n
										{: RESULT = ast.new Termino(n);:}

										| TRUE_LITERAL:n
										{: RESULT = ast.new Termino("True");:}

										| FALSE_LITERAL
										{: RESULT = ast.new Termino("False");:}

										| llamado_funcion:lf
										{: RESULT = ast.new Termino(lf);:};

tipo_dato							::=	ENTERO
										{: RESULT = ast.new TipoDato("Integer");:}

										| REAL
										{: RESULT = ast.new TipoDato("Double");:}

										| CADENA
										{: RESULT = ast.new TipoDato("String");:}

										| CARACTER
										{: RESULT = ast.new TipoDato("Character");:}

										| BOOLEAN
										{: RESULT = ast.new TipoDato("Boolean");:}

										| IDENTIFICADOR:id
										{: RESULT = ast.new TipoDato(id);:} /*Puede ser un nuevo tipo de dato*/;

visibilidad							::=	PUBLIC
										{:	RESULT = ast.new Visibilidad("Public");:}

										| PRIVATE
										{:	RESULT = ast.new Visibilidad("Private");:}

										| {:RESULT = ast.new Visibilidad("");:};

// lista_variables						::= IDENTIFICADOR:id
// 										| lista_variables:lv COMA IDENTIFICADOR:id
// 										| error{:parser.report_error("lista_variables: Se esperaba una lista_variables", "\t");:} COMA IDENTIFICADOR
// 										| lista_variables error{:parser.report_error("lista_variables: Se esperaba COMA", "\t");:} IDENTIFICADOR
// 										| lista_variables COMA error{:parser.report_error("lista_variables: Se esperaba IDENTIFICADOR", "\t");:};

tipos_step						::= ENTERO_LITERAL:n
									{:	RESULT = Integer.toString(n);:}
										
									| REAL_LITERAL:n
									{:	RESULT = Double.toString(n);:};	